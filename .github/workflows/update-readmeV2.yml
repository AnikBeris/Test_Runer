name: V2 UPDATE-README

# Запускается вручную, по расписанию и при изменении частей README
on:
  workflow_dispatch:                                 # Ручной запуск из вкладки Actions
  schedule:
    - cron: '10 9 * * *'                             # Каждый день в 09:10 UTC = 12:10 по Москве
  push:
    branches: [ main ]
    paths:
      - ".github/README_PARTS/*"                     # Любое изменение в папке с кусочками
      - ".github/README_PARTS/5.MAIN_Article_*.md"   # Особенно важно — новые/изменённые статьи

# Обязательные права, без них будет ошибка 403
permissions:
  contents: write          # Позволяет создавать ветки, коммитить и пушить временную ветку
  pull-requests: write     # Нужно для создания Pull Request

jobs:
  # 1. Подготовка — просто информация + клонирование репозитория
  prepare:
    runs-on: ubuntu-latest
    name: Подготовка
    steps:
      - name: Информация о запуске
        run: |
          echo "Событие: ${{ github.event_name }}"
          echo "Репозиторий: ${{ github.repository }}"
          echo "Ветка: ${{ github.ref_name }}"
          date '+%Y-%m-%d %H:%M:%S (UTC)'

      - name: Клонирование репозитория
        uses: actions/checkout@v4
        with:
          fetch-depth: 0        # Полная история нужна для корректной работы git

  # 2. Настройка автора коммитов — отдельный шаг для красоты в логах
  setup-git:
    needs: prepare
    runs-on: ubuntu-latest
    name: Настройка Git
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Установить автора коммитов
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          echo "Git настроен под github-actions[bot]"

  # 3. Основная работа — сборка одного большого README.md из кусочков
  compile-readme:
    needs: setup-git
    runs-on: ubuntu-latest
    name: Сборка README
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Сборка README.md из частей
        run: |
          PARTS=".github/README_PARTS"
          OUTPUT="README.md"

          # Пути к обязательным файлам
          HEADER="$PARTS/1.HEADER.md"
          DESCRIPTION="$PARTS/2.DESCRIPTION.md"
          DONATION="$PARTS/3.DONATION.md"
          NAV="$PARTS/4.NAV.md"
          MAIN_Header="$PARTS/5.MAIN_Header.md"
          FOOTER="$PARTS/6.FOOTER.md"

          # Находим и сортируем статьи по номеру (01, 02, 10…)
          MAIN_ARTICLES=$(ls "$PARTS"/5.MAIN_Article_*.md 2>/dev/null | sort -V || echo "")

          echo "Найдено статей:"
          echo "$MAIN_ARTICLES" | sed 's/^/  • /' || true

          # Проверка, что все обязательные файлы на месте
          for file in "$HEADER" "$DESCRIPTION" "$DONATION" "$NAV" "$MAIN_Header" "$FOOTER"; do
            [[ -f "$file" ]] || { echo "ОШИБКА: не найден файл $file"; exit 1; }
          done

          echo "Собираем $OUTPUT …"
          > "$OUTPUT"   # очищаем/создаём файл

          # Последовательно склеиваем всё с отступами в 2 пустые строки
          cat "$HEADER"        >> "$OUTPUT"; echo -e "\n\n" >> "$OUTPUT"
          cat "$DESCRIPTION"   >> "$OUTPUT"; echo -e "\n\n" >> "$OUTPUT"
          cat "$DONATION"      >> "$OUTPUT"; echo -e "\n\n" >> "$OUTPUT"
          cat "$NAV"           >> "$OUTPUT"; echo -e "\n\n" >> "$OUTPUT"
          cat "$MAIN_Header"   >> "$OUTPUT"; echo -e "\n\n" >> "$OUTPUT"

          # Добавляем все статьи по порядку
          if [[ -n "$MAIN_ARTICLES" ]]; then
            for article in $MAIN_ARTICLES; do
              echo "Добавляем: $(basename "$article")"
              cat "$article" >> "$OUTPUT"
              echo -e "\n\n" >> "$OUTPUT"
            done
          else
            echo "Внимание: статей не найдено"
          fi

          cat "$FOOTER" >> "$OUTPUT"
          echo -e "\n" >> "$OUTPUT"

          echo "README.md успешно собран и готов к отправке!"

      # Передаём собранный файл в следующий job
      - name: Сохранить README как артефакт
        uses: actions/upload-artifact@v4
        with:
          name: compiled-readme
          path: README.md
          retention-days: 1

  # 4. Создаём Pull Request вместо прямого пуша в main
  create-pull-request:
    needs: compile-readme
    runs-on: ubuntu-latest
    name: Создание Pull Request
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Получаем готовый README.md из предыдущего шага
      - name: Скачать собранный README.md
        uses: actions/download-artifact@v4
        with:
          name: compiled-readme
          path: .

      # 1. Создаём Pull Request
      - name: Создать PR и авто-мердж (pascalgn)
        uses: pascalgn/automerge-action@v0.16.4
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          # Конфигурация мержа (актуальные параметры v0.16.4)
          MERGE_LABELS: "automated"                    # Метка, которая триггерит мерж (было MERGE_LABEL — убрали!)
          MERGE_METHOD: "squash"                       # Squash для чистой истории
          MERGE_COMMIT_MESSAGE: "chore: regenerate README from parts (авто)"  # Кастомное сообщение
          MERGE_DELETE_BRANCH: "true"                  # Удаляем ветку после мержа
          MERGE_REMOVE_LABELS: "automated"             # Убираем метку после мержа

          # Конфигурация обновления PR (rebase на base)
          UPDATE_METHOD: "rebase"                      # Rebase для обхода "up to date"
          UPDATE_LABELS: "automated"                   # Та же метка для обновления

          # Фильтры (только для твоего бота)
          MERGE_FILTER_AUTHOR: "github-actions[bot]"   # Только PR от бота

          # Дополнительно (опционально, для надёжности)
          MERGE_RETRIES: "3"                           # 3 попытки, если checks висят
          MERGE_RETRY_SLEEP: "10000"                   # 10 сек между попытками
          MERGE_FORKS: "false"                         # Не мержим форки (для безопасности)